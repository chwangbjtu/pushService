#include <iostream>
#include <stdlib.h>
#include <arpa/inet.h>
#include <string>
#include "encrypt_lgsr.h"

using namespace std;

encrypt_lgsr* encrypt_lgsr::_inst = NULL;
encrypt_lgsr* encrypt_lgsr::instance()
{
	if ( _inst == NULL)
	{
		_inst = new encrypt_lgsr();
	}
	return _inst;
}


encrypt_lgsr::encrypt_lgsr()
{
	_algsr1 = new arithmetic1_lgsr();
	
	int idx = 1;//encrypt algorithm index 1
	this->register_arithmetic(idx,_algsr1);

}

encrypt_lgsr::~encrypt_lgsr(){}


//for arith_lgsr
arithmetic1_lgsr::arithmetic1_lgsr()
{
    KEY_LEN1 = 128;
    _secret_key = (unsigned char*)malloc(KEY_LEN1);
    _secret_key[0] = 0xDC;_secret_key[1] = 0x47;_secret_key[2] = 0xE2;_secret_key[3] = 0xA6;
    _secret_key[4] = 0x0D;_secret_key[5] = 0x70;_secret_key[6] = 0x71;_secret_key[7] = 0x21;
    _secret_key[8] = 0x6D;_secret_key[9] = 0x21;_secret_key[10] = 0x28;_secret_key[11] = 0xDD;
    _secret_key[12] = 0xD1;_secret_key[13] = 0x6D;_secret_key[14] = 0x20;_secret_key[15] = 0xA4;
    _secret_key[16] = 0xAC;_secret_key[17] = 0x88;_secret_key[18] = 0x0A;_secret_key[19] = 0x75;
    _secret_key[20] = 0xD5;_secret_key[21] = 0x7F;_secret_key[22] = 0x12;_secret_key[23] = 0xD4;
    _secret_key[24] = 0x8A;_secret_key[25] = 0x26;_secret_key[26] = 0x0A;_secret_key[27] = 0x65;
    _secret_key[28] = 0xB4;_secret_key[29] = 0x52;_secret_key[30] = 0xC4;_secret_key[31] = 0xB9;
    _secret_key[32] = 0x6C;_secret_key[33] = 0x49;_secret_key[34] = 0xBF;_secret_key[35] = 0x68;
    _secret_key[36] = 0xBF;_secret_key[37] = 0x77;_secret_key[38] = 0x06;_secret_key[39] = 0x60;
    _secret_key[40] = 0xAE;_secret_key[41] = 0x63;_secret_key[42] = 0x56;_secret_key[43] = 0x7C;
    _secret_key[44] = 0x79;_secret_key[45] = 0xE1;_secret_key[46] = 0x7F;_secret_key[47] = 0x59;
    _secret_key[48] = 0x1E;_secret_key[49] = 0x88;_secret_key[50] = 0x0C;_secret_key[51] = 0x65;
    _secret_key[52] = 0x1C;_secret_key[53] = 0x66;_secret_key[54] = 0x26;_secret_key[55] = 0x38;
    _secret_key[56] = 0x7C;_secret_key[57] = 0xF3;_secret_key[58] = 0xB6;_secret_key[59] = 0x28;
    _secret_key[60] = 0x12;_secret_key[61] = 0x44;_secret_key[62] = 0xCA;_secret_key[63] = 0x17;
    _secret_key[64] = 0x01;_secret_key[65] = 0x81;_secret_key[66] = 0x3A;_secret_key[67] = 0x90;
    _secret_key[68] = 0x7D;_secret_key[69] = 0x99;_secret_key[70] = 0x8B;_secret_key[71] = 0x13;
    _secret_key[72] = 0xD5;_secret_key[73] = 0x34;_secret_key[74] = 0x13;_secret_key[75] = 0xAC;
    _secret_key[76] = 0xB0;_secret_key[77] = 0xEA;_secret_key[78] = 0x5E;_secret_key[79] = 0xCA;
    _secret_key[80] = 0x96;_secret_key[81] = 0xB2;_secret_key[82] = 0xD1;_secret_key[83] = 0x4F;
    _secret_key[84] = 0xB3;_secret_key[85] = 0x9D;_secret_key[86] = 0x8D;_secret_key[87] = 0xE4;
    _secret_key[88] = 0xD8;_secret_key[89] = 0xC4;_secret_key[90] = 0x97;_secret_key[91] = 0x8F;
    _secret_key[92] = 0xC3;_secret_key[93] = 0x7E;_secret_key[94] = 0x35;_secret_key[95] = 0x87;
    _secret_key[96] = 0xA0;_secret_key[97] = 0xD7;_secret_key[98] = 0x9B;_secret_key[99] = 0x47;
    _secret_key[100] = 0xD0;_secret_key[101] = 0x3E;_secret_key[102] = 0xC6;_secret_key[103] = 0xE1;
    _secret_key[104] = 0xE8;_secret_key[105] = 0x7E;_secret_key[106] = 0xA9;_secret_key[107] = 0x95;
    _secret_key[108] = 0xFD;_secret_key[109] = 0xF0;_secret_key[110] = 0x87;_secret_key[111] = 0xA2;
    _secret_key[112] = 0x1F;_secret_key[113] = 0xEE;_secret_key[114] = 0xA0;_secret_key[115] = 0x5C;
    _secret_key[116] = 0x23;_secret_key[117] = 0x8A;_secret_key[118] = 0x0F;_secret_key[119] = 0x7F;
    _secret_key[120] = 0xA6;_secret_key[121] = 0x80;_secret_key[122] = 0xF3;_secret_key[123] = 0xC3;
    _secret_key[124] = 0x4E;_secret_key[125] = 0x6A;_secret_key[126] = 0xCD;_secret_key[127] = 0xB0;
	//memcpy(_ckey,tkey,size*sizeof(unsigned int));
}

arithmetic1_lgsr::~arithmetic1_lgsr(){}

int arithmetic1_lgsr::getlen(unsigned char* header)
{
	encrypt_char_t* p_encrypt_char = (encrypt_char_t*)header;
	//unsigned int key = p_encrypt_char->_random ^ _ckey[p_encrypt_char->_k_index];
	unsigned int key_index = p_encrypt_char->_k_index<<3;
    unsigned int rand_key = p_encrypt_char->_random;//_random is unsigned short
    rand_key = (rand_key<<16)|rand_key;

    int len = -1;

    int j = 4;
    //p_encrypt_char->_k_index只有4位，最大只能取值到15，左移3位（就是乘以8）后最大只能是120
    //不会超过127个的密钥
    len = (*(unsigned int*)(&header[j])) ^ ( (*(unsigned int*)(&_secret_key[key_index])) ^ rand_key );
    //no need ntohl ,it will change in encrypt_base::getlen soon
    //len = ntohl(len);
    printf("%u,%d,%d,%d",ntohl(len),(*(unsigned int*)(&header[j])),(*(unsigned int*)(&_secret_key[key_index])),rand_key);

	return len;
}

int arithmetic1_lgsr::encrypt(unsigned char *pkt, int len)
{
    if ( len < 16)
        return -1;

    unsigned short checksum = get_checksum(pkt,len);
    unsigned short * pchecksum = (unsigned short*)(pkt+14);
    *pchecksum = htons(checksum);
    for(int i =0;i<16;i++)
    {
        printf("%x,",(unsigned char)pkt[i]);
    }
    cout<<endl;

    xor_operation((unsigned char*)(pkt),len);
    for(int i =0;i<16;i++)
    {
        printf("%x,",(unsigned char)pkt[i]);
    }
    cout<<endl;
	return 0;//success
}

int arithmetic1_lgsr::decrypt(unsigned char *pkt, int len)
{
    cout<<__FUNCTION__<<":"<<__LINE__<<endl;
    if ( len < 16)
        return -1;
    
    cout<<__FUNCTION__<<":"<<__LINE__<<endl;
    unsigned short checksum = ntohs(*(unsigned short*)(pkt+14));
    unsigned short * pchecksum = (unsigned short*)(pkt+14);
    *pchecksum = 0;
    unsigned short tchecksum = get_checksum(pkt,len);
    if ( checksum != tchecksum)
    {
        cout<<__FUNCTION__<<":"<<__LINE__<<endl;
        return -2;
    }
    cout<<__FUNCTION__<<":"<<__LINE__<<endl;
    
    xor_operation((unsigned char*)(pkt),len);
    cout<<__FUNCTION__<<":"<<__LINE__<<endl;

    return 0;
	
	//return p_encrypt_char->_second_c_len;//success
}

int arithmetic1_lgsr::get_checksum(unsigned char *pkt, int len)
{
    if ( len < 16)
        return -1;

    unsigned short checksum = *((unsigned short*)pkt);
    for( int i=2;i<16;i = i+2)
    {
        checksum = checksum ^ *((unsigned short*)(pkt+i));
    }

    return checksum;
}

int arithmetic1_lgsr::xor_operation(unsigned char* msg,int len)
{
	//为了能够寻址到所有的key，
	//_k_index只有4位，最大只能表示16，密钥有128个；只有乘以8,才能寻址到128 
	//arithmetic index
	encrypt_char_t* p_encrypt_char = (encrypt_char_t*)msg;
    unsigned int key_index = p_encrypt_char->_k_index<<3; 
    unsigned int rand_key = p_encrypt_char->_random;//_random is unsigned short
    len = len -4;
    msg = msg + 4;

    int tlen = len - len%2;
    unsigned int ki = key_index;
    int j = 0;//用户数据的索引

    printf("ttt1,%x,%x,%x\n",key_index,rand_key,(*(unsigned short*)(&_secret_key[ki])));

    for (;j<tlen;)
    {
        for(;ki<=KEY_LEN1-2 && j<tlen ;)
        {
            (*(unsigned short*)(&msg[j])) ^= (*(unsigned short*)(&_secret_key[ki])) ^ rand_key;
            ki += 2;
            j += 2;
        }
        //ki（key的索引超过128之后再从0开始）
        ki = 0;
    }

    if ( ki > KEY_LEN1-2)
        ki = 0;
    if ( len %2 != 0)
    {
        unsigned char ran = p_encrypt_char->_ran;
        (*(unsigned char*)(&msg[j])) ^= (*(unsigned char*)(&_secret_key[ki])) ^ ran;
    }

	return 0;
}


